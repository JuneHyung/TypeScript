# 3장 클래스와 인터페이스를 사용한 객체 지향 프로그래밍

이번 장에서는 객체지향프로그래밍 관점으로 클래스와 인터페이스를 배워볼 것이다.

객체 지향 언어를 사용하는 개발자는 클래스에 특정 API를 적용하는 방법으로 인터페이스를 사용합니다.

# 3.1 클래스 사용

## 2장 복습

* 객체 지향 언어는 멤버 변수로 클래스를 선언할 수 있다.
* JS에서는 클래스 내 생성자를 선언할 수 있으며 인스턴스 생성 중 한번만 호출한다.
* 컴파일 타겟이 ES5인 경우 타입스크립트 컴파일러는 타입스크립트 클래스를 자바스크립트 생성자 함수로 변환함.<br/>ES6이상이면 자바스크립트 클래스로 컴파일됨.
* 생성자 파라미터를 readonly, public, protected, private 키워드로 정의하면 타입스크립트는 각 파라미터에 대한 클래스 프로퍼티를 만듬.



## 3.1.1 클래스 상속

keyword : **extends**

타입스크립트도 부모로부터 기능을 상속을 받습니다.

기존 클래스를 기반으로 새 클래스를 만들 수 있습니다.

```typescript
class Person {
    firstName = '';
    lastName = '';
    age =0;
}

class Employee extends Person {
    department = '';
}

const empl = new Employee();
// empl.age;
```

empl. 후 ctrl+Enter하면 자동완성 목록에 Person의 요소들이 있는 걸 볼 수 있다.

Person클래스는 부모이고, Employee는 Person을 상속받은 자식클래스가 됩니다.



클래스는 프로퍼티 외에도 메서드를 가집니다.

메서드로 클래스 내부에 선언된 함수를 호출합니다. (private가 아니라면 서브클래스에 상속됨.)

```typescript
class Person {
    firstName = '';
    lastName = '';
    age =0;
    
    sayHello(): string {
        return `My name is ${this.firstName} ${this.lastName}`;
    }
}

class Employee extends Person {
    department = '';
}

const empl = new Employee();
// empl.sayHello
```

empl.에서 자동완성하면 sayHello가 뜬다.



## 3.1.2 public, private, protected 접근 제어자

접근제어자로 클래스 멤버 접근 권한을 제어합니다.

* public : 클래스 멤버는 모든 내부 및 외부 클래스 접근가능.
* protected : 동일 패키지에 속하는 클래스와 서브 클래스 관계일 경우만 접근가능
* private : 클래스 내에서만 접근가능.

```typescript
class Person {
    public firstName = '';
    public lastName = '';
    private age =0;
    
    protected sayHello(): string {
        return `My name is ${this.firstName} ${this.lastName}`;
    }
}

class Employee extends Person {
    department = '';
    
    reviewPerformance(): void {
        this.sayHello();
        this.increasePay(5);
    }
    
    increasePay(percent: number): void{
 //       this.
    }
}

const empl = new Employee();
empl.sayHello(); // 오류 발생
```

this.에서 자동완성 시 private인 age는 보이지 않는게 보인다.

sayHello는 protected로 선언 되었기 때문에 클래스 인스턴스에서는 접근이 안된다.

```typescript
class Person {
    public firstName = '';
    public lastName = '';
    private age =0;
    
   constructor(firstName: string, lastName: string, age: number){
       this.firstName = firstName;
       this.lastName = lastName;
       this.age = age;
   }
}
```

javascript

```javascript
class Person {
    constructor(public firstName: string,
                public lastName: string,
                private age: number){ }
}

const pers = new Person('John', 'Smith', 29)
console.log(`${pers.firstName} ${pers.lastName} ${pers.age}`)
```

js에서 age에서 빨간 줄이 표시된다. => private이기 때문.



! 실제로 개발 시 noEmitOnError옵션을 사용하여 모든 오류가 없으면 자바스크립트를 생성하도록 설정한다.



## 3.1.3 고정 변수와 싱글톤

ES6부터 클래스의 각 인스턴스가 일부 프로퍼티를 공유해야하는 경우 정적 프로퍼티로 선언합니다.

타입스크립트는 static 키워드를 지원합니다.

**static과 private생성자로 싱글톤 디자인 패턴을 구현**해보자.

```typescript
class Gangsta {
    static totalBullets = 100;
    shoot(){
        Gangsta.totalBullets--;
        console.log(`Bullets left : ${Gangsta.totalBullets}`);
    }
}

const g1 = new Gangsta();
g1.shoot(); // 99

const g2 = new Gangsta();
g2.shoot(); // 98
```

두 인스턴스는 동일한 변수 totalBullets를 공유하므로 99 -> 98 로 변했다.

shoot()의 this.totalBullets는 인스턴스 변수가 아니기 때문에 사용하지 않았습니다. static클래스 멤버 앞에 해당 클래스 이름을 붙이면 접근 가능합니다.



! static인 클래스 멤버는 서브클래스에 공유되지 않습니다.<br/>SuperGangsta클래스가 Gangsta의 서브클래스라면 totalBullets 프로퍼티를 복사해 그대로 가져옵니다.<br/>참고 : goo.gl/3BSnjZ



한 곳에서만 앱 전체 상태를 관리하며, 외부에서 접근 가능한 객체를 만들어 보자.<br/>전체 데이터를 한 곳에서 관리하는 우너칙을 단일 데이터 소스 또는 단일 진실 공급원이라고함.

객체 지향 언어에서 **단 하나의 인스턴스를 생성하는 디자인 패턴**을 **싱글톤** 이라고 합니다.

new 키워드로 원하는 만큼 여러 인스턴스를 생성할 수 있기 때문에 new 키워드사용을 막아야합니다.

단일 인스턴스를 만드는 방법?

클래스 생성자가 private인 경우 클래스 내에서만 접근 가능하다는 문제가 있습니다.<br/>**static키워드로 클래스 메서드를 정적 메서드로 만들면 특정 인스턴스가 아닌 클래스에만 속하도록 만들 수 있음**

예제

* AppState 싱글톤 디자인 패턴으로 counter를 가짐.
* counter는 외부에서 접근 가능하며 단일 인스턴스에서만 그 값을 저장함.
* counter의 값을 읽는 메서드 역시 AppState 인스턴스에서 가져옴.

```typescript
class AppState{
    counter = 0; // 앱 상태를 나타냄.
    private static instanceRef: AppState;
    private constructor() {}
	static getInstance(): AppState{
        if(AppState.instanceRef === undefined){
            AppState.instanceRef = new AppState();
        }
        return AppState.instanceRef;
    }
}

// const appState = new AppState(); // private 생성자 때문에 오류 발생

// AppState 인스턴스에 대한 참조를 가져옴.
const appState1 = AppState.getInstance();
const appState2 = AppState.getInstance();

appState1.counter++;
appState1.counter++;
appState2.counter++;
appState2.counter++;

console.log(appState1.counter)
console.log(appState2.counter)
```

AppState클래스는 private 생성자가 있으므로 new 키워드로 생성이 불가.

getInstance() 메소드로 생성자를 호출 가능.<br/>정적 메소드로 크랠스 인스턴스가 없을 때 메서드를 호출할 수 있다.

