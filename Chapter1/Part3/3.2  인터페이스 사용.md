# 3.2  인터페이스 사용

생성자를 포함시킨 커스텀 타입이 필요한 경우 일반클래스를 사용 / 그렇지 않으면 인터페이스 사용함



## 3.2.1 인터페이스 강제

속성 뿐만 아니라 메서드선언도 포함할 수 있다. ( ❗ 메서드 구현은 아님. )

**implements키워드와 인터페이스 이름**을 사용할 수 있음.

=> 메서드 시그니처만을 포함하지만, 클래스는 메서드 구현이 포함될 수 있다.



### 👉 Example

```typescript
// 3_13.ts
interface MotorVeghicle3_13{
  startEngine(): boolean;
  stopEngine(): boolean;
  brake(): boolean;
  accelate(speed: number);
  hank(HowLong: number): void;
}
```

메서드 구현은 없음.

위 메서드를 구현하는 클래스 Car를 만들어보자.

```typescript
class Car3_13 implements MotorVehicle3_13{

}
```

이 경우 클래스 선언은 컴파일되지 않아 오류가 발생.

**인터페이스로 클래스를 선언할 때, 인터페이스 내 각 메서드를 구현해야함.**

```typescript
// 3_14.ts
interface MotorVehicle3_14{
  startEngine(): boolean;
  stopEngine(): boolean;
  brake(): boolean;
  accelate(speed: number);
  hank(HowLong: number): void;
}

class Car3_14 implements MotorVehicle3_14{
  startEngine(): boolean{
    return true;
  }
  stopEngine(): boolean{
    return true;
  }
  brake(): boolean{
    return true;
  }
  accelate(speed: number){
    console.log(`Driving faster`);
  }
  hank(HowLong: number): void {
    console.log(`Beep beep yeah!`);
  }
}

const car = new Car3_14();
car.startEngine();
```

car의 타입을 명시적으로 선언하지 않았습니다. 

```typescript
const car: Car3_14 = new Car3_14();
```

이 처럼 명시적으로 선언 가능.

```typescript
const car:MotorVehicle3_14 = new Car3_14();
```

Car클래스는 커스텀 타입을 구현하므로 상수 car에 Motor Vehicle타입 선언 가능



### 차이점

위 두가지의 차이점을 알아보자.

만약 Car가 8개의 메소드를 구현해야한다고 하면, **Car타입이면, 객체 인스턴스내 8개를 모두 호출** 가능.<br/>**MotorVehicle타입이면 인스턴스에 선언된 메서드만 호출** 가능

이를 인터페이스는 특정 규약을 강제한다고 말할 수 있다.

---

```typescript
// 3_15.ts
interface Flyable3_15{
    fly(howHigh: number);
    land();
}

interface Swimmable3_15{
    swim(howFar: number);
}
```



앞의 3가지를 합쳐보자.

```typescript
// 3_16.ts
class Car3_16 implements MotorVehicle3_16, Flyable3_16, Swimmable3_16{
	// 3개의 인터페이스 내 모든 메서드를 구현
}
```

Car전체에 Flyable과 Swimmable을 가능하도록 하는건 좋은 방법이 아님.

상속개념을 적용해 Car클래스를 확장하고, 기능을 추가해보자.

```typescript
class SecretServiceCar3_17 extends Car3_17 implements Flyable3_17, Swimmable3_17{
  // flyable과 swimmable 내 모든 메서드를 구현
}
```

Car클래스가 MotorVehicle 인터페이스에 정의된 기능을 가짐.



## 3.2.2 인터페이스 확장

MotorVehicle인터페이스 내의 각 메서드를 다르게 구현할 수도 있습니다.

```typescript
// 3_18.ts
class SecretServiceCar3_18 implements MotorVehicle3_18, Flyable3_18, Swimmable3_18{
  // 3가지 인터페이스 내 모든 메서드를 구현
}
```



**인터페이스 확장**

```typescript
// 3_19.ts
interface MotorVehicle3_19{
  startEngine(): boolean;
  stopEngine(): boolean;
  brake(): boolean;
  accelate(speed: number);
  hank(HowLong: number): void;
}

interface Flyable3_19 extends MotorVehicle3_19{
    // 클래스를 구현하는 메서드 시그니처
  fly(howHigh: number);
  land();
}
```



이 후 클래스 선언에 implements Flyable 구문이 포함되 있으면 MotorVehicle 인터페이스에 선언된 5개 메서드와 Flyable의 두 메서드를 합친 총 7개의 메서드를 구현해야함.



```typescript
// 3_20.ts
class SecretServiceCar3_20 implements Flyable3_20, Swimmable3_20{
  startEngine(): boolean{
    return true;
  }
  stopEngine(): boolean{
    return true;
  }
  brake(): boolean{
    return true;
  }
  accelate(speed: number){
    console.log(`Driving faster`);
  }
  hank(howLong: number): void{
    console.log(`Beep Beep!!`)
  }
  fly(howHigh: number){
    console.log(`Flying ${howHigh} feet high`);
  }
  land(){
    console.log(`Landing. Fasten your belts`);
  }
  swim(howFar: number){
    console.log(`Swimming ${howFar} feet`);
  }
}
```

메서드 시그니처를 포함한 인터페이스 선언은 코드 가독성을 높여줌.

**인터페이스는 각 기능이 잘 정의된 집합**으로 인터페이스를 이용해 **구체적인 클래스를 구현**할 수 있다.



## 3.2.3 인터페이스 프로그래밍

먼저 인터페이스 프로그래밍을 사용할 수 없는 경우를 보자.

한가지 또는 모든 제품 정보를 읽는 코드를 작성해야 한다고 할 때, 먼저 클래스를 만들고 각 기능을 바로 구현하는 데 집중할 것입니다.

### 👉 Example

```typescript
class Product{
  id: number;
  description: string;
}

class ProductService{
  getProducts(): Product[]{
    // 모든 products 정보를 가져옴.
    return [];
  }

  getProductById(id: number): Product{
    // id를 조회해 product의 정보를 가져옴.
    return {id: 123, description: 'Good product'};
  }
}
```

그러고 나서 아래와 같이 ProductService 인스턴스를 만들고 메서드를 사용할 수 있다.

```typescript
const productService = new ProductService();
const products = productService.getProducts();
```



서버가없으니 동일한 API를 사용하는 MockProductService클래스를 생성하고 제품데이터를 반환할 수 있게 만들어 보자.

```typescript
// 3_22.ts
class MockProductService3_22{
	getProducts(): Product3_22[]{
    // 하드 코딩된 제품 정보를 받는 코드 작성.
    return [];
  }
  getProductById(id: number): Product3_22{
    return {id: 456, description: 'Not a real product'};
  }
}
```

MockProductService클래스는 ProductService 클래스와 동일한 두 메서드를 선언했지만, 반대의 경우 오류가 발생할 수 있다.

=> 이를 방지하기 위해 MockProductService 클래스에 인터페이스를 강제할 수 있습니다.

implements키워드로 다른 클래스를 구현하는 클래스를 만들 수 있기 때문에 아래와 같이 MockProductService클래스를 수정하는 것이 바람직함.

```typescript
class MockProductService3_22 implements ProductService{
    // 구현
}
```

